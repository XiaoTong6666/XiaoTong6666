# Scene 8 Daemon 逆向工程与分析报告

## 1. 项目目标
**目标**: 分析 Scene 8 (Scene-Daemon) 的激活逻辑，获取通信协议，并寻找绕过激活验证的方法。

## 2. 逆向分析流程 (Analysis Workflow)

### 阶段一：初步侦查 (Reconnaissance)
- **文件识别**: 原始二进制文件是一个静态链接的 Go 程序，但经过了严重的混淆和加壳。
- **Shell 脚本分析**: 用户指出的启动脚本 `up.sh` (位于 `/data/data/com.omarea.vtools/files/up.sh`) 显示：
  - 它首先设置环境（如 BusyBox）。
  - 然后将 `scene-daemon` 复制到缓存目录。
  - 最后直接运行二进制文件 (`nohup $target_path ...`)。
  - **纠正**: 此前关于 `app_process` 和 `CLASSPATH` 的推测是不准确的，Daemon 是一个直接运行的 Native ELF 程序。
- **Stage 1 (Loader)**: 入口点 ([entry](file:///home/xiaotong/ghidra/bridge_mcp_ghidra.py#3378-3390)) 代码即使在 IDA/Ghidra 中也难以识别，表现为自定义的 LZMA 解压 Stub。

### 阶段二：脱壳与内存转储 (Unpacking & Dumping)
由于静态分析受阻，我们将重点转向运行时内存转储。

#### 尝试 A: 直接使用 [dd](file:///home/xiaotong/ghidra/bridge_mcp_ghidra.py#3658-3691) 或 [cat](file:///home/xiaotong/ghidra/bridge_mcp_ghidra.py#1691-1711) (失败)
- **现象**: 即使作为 Root 用户，直接对 `/proc/pid/mem` 进行 [dd](file:///home/xiaotong/ghidra/bridge_mcp_ghidra.py#3658-3691) 或 [cat](file:///home/xiaotong/ghidra/bridge_mcp_ghidra.py#1691-1711) 也会返回 `I/O error` 或得到 0 字节文件。
- **原因**: 系统对某些敏感进程内存段设置了保护，常规的文件系统访问会被阻断。

#### 尝试 B: 使用 Frida (成功但有限制)
- **思路**: 注入进程并主动导出内存。
- **优点**: 能够捕获解密瞬间。
- **缺点**: 依赖设备上的 Frida Server 环境，且可能触发某些加壳工具的运行时反调试检测。

#### 尝试 C: 使用 `ptrace` 附着转储 (最可靠的正确流程)
- **思路**: 使用 `ptrace(PTRACE_ATTACH)` 暂停目标进程，使系统将其标记为正在被调试，从而获得合法的内存访问权限，然后通过 `pread` 绕过保护直接读取 `/proc/pid/mem`。
- **流程**:
    1.  定位 PID (`pidof scene-daemon`)。
    2.  寻找目标段（搜索 `\x7fELF` 魔数）。
    3.  使用 C 工具 (如 [scan_mem](file:///home/xiaotong/EzXHepler-template/scan_mem)) 执行以下原子操作：
        - `ptrace(PTRACE_ATTACH, pid, ...)` 
        - `waitpid(...)` 等待暂停。
        - `pread(fd, buf, size, offset)` 从 `/proc/pid/mem` 读取数据。
        - `fwrite(...)` 保存到本地。
        - `ptrace(PTRACE_DETACH, ...)` 恢复进程正常运行。
- **成果**: 成功获取 [stage4_unpacked_ram.elf](file:///home/xiaotong/EzXHepler-template/stage4_unpacked_ram.elf) (8.6MB)，该流程不依赖 Frida，具有更强的通用性和隐蔽性。

### 阶段三：运行时保护绕过 (Bypassing Runtime Protection)
在尝试分析运行时状态时，遇到了强劲的 **Anti-Dump** 保护。

- **现象**: 即使拥有 Root 权限，读取 Daemon 的代码段 (`r-x`) 依然返回 **全零 (Zeros)**。这通常是 **XOM (Execute-Only Memory)** 技术。
- **对抗尝试**:
    1.  **编写 C 工具**: [inject_mprotect.c](file:///home/xiaotong/EzXHepler-template/inject_mprotect.c)。
    2.  **原理**: 使用 `ptrace` 附加进程，强行通过 [mprotect](file:///home/xiaotong/EzXHepler-template/inject_mprotect) 系统调用将内存权限修改为 `rwx` (可读可写可执行)。
    3.  **结果**: [mprotect](file:///home/xiaotong/EzXHepler-template/inject_mprotect) 返回成功 (0)，权限位显示 `rwx`，但读取内容 **依然是零**。这说明保护是在内核页表层面或硬件层面的。
    
    > **[验证补充]** 使用 `adb` 再次验证 XOM 保护：
    > ```bash
    > # 1.以此命令定位代码段 (r-xp)
    > adb shell "su -c 'pid=\$(pidof scene-daemon); cat /proc/\$pid/maps | grep r-xp | head -n 1'"
    > # 输出: 5d1b7c0000-5d1bba4000 r-xp 00000000 fb:00 44   /data/user/0/com.omarea.vtools/files/scene-daemon
    > 
    > # 2.尝试读取该段内存 (前 32 字节)
    > adb shell "su -c 'dd if=/proc/\$(pidof scene-daemon)/mem bs=1 skip=\$((0x5d1b7c0000)) count=32 2>/dev/null | xxd'"
    > # 输出: 00000000: 0000 0000 0000 0000 0000 0000 0000 0000  ................
    > # (全零确认: 即使是 Root 用户也无法读取代码段内容)
    > ```

### 阶段四：静态分析与协议还原 (Static Analysis)
由于运行时 Dump 受阻，我们回到了 **阶段二** 获取的 [stage4_unpacked_ram.elf](file:///home/xiaotong/EzXHepler-template/stage4_unpacked_ram.elf)。

- **Go 符号恢复**: 尝试解析 [pclntab](file:///home/xiaotong/EzXHepler-template/find_pclntab.py#4-71) (Go Symbol Table) 失败，头部被抹除。
- **关键字符串定位**:
    - 发现字符串 `activate` (位于偏移 `0xD535D`，实际为 `activatepineappl...`)。
    - 发现 `crypto/aes` 相关 Go 符号，确认使用了 AES 加密。
- **逻辑还原**:
    - 定位到函数 `FUN_00475770` (在 `0x475770`)。
    - 发现该函数引用了 `activate` 字符串。
    - 确认它处于 HTTP 处理上下文中。
    - 推导出通信协议：客户端发送 `activate` -> 服务端校验 -> 返回加密的 `success@<expire>`。

## 3. 开发的辅助工具 (Custom Tools)

在整个过程中，我们编写了大量定制工具来应对特定环境的限制：

| 工具名称 | 语言 | 用途 | 关键技术点 |
| :--- | :--- | :--- | :--- |
| [scan_mem.c](file:///home/xiaotong/EzXHepler-template/scan_mem.c) | C | 内存搜索与转储工具 | **核心脱壳工具**。通过 `ptrace` 绕过访问限制，执行 ELF 魔数搜索和内存段转储。 |
| [dump.js](file:///home/xiaotong/EzXHepler-template/dump.js) | JavaScript | Frida Payload | Hook [mprotect](file:///home/xiaotong/EzXHepler-template/inject_mprotect) 监控解压行为，并导出内存镜像。 |
| [frida_manager.py](file:///home/xiaotong/EzXHepler-template/frida_manager.py) | Python | 自动化 Frida 注入 | 协调多设备，处理进程生命周期与日志捕获. |
| [gen_mock_response.py](file:///home/xiaotong/EzXHepler-template/gen_mock_response.py)| Python | 协议分析与响应生成 | 实现 AES-256-ECB 加密、PKCS7 填充及密钥派生逻辑。 |
| [inject_mprotect.c](file:///home/xiaotong/EzXHepler-template/inject_mprotect.c) | C | 权限修改验证工具 | 测试 XOM 保护，使用 `ptrace` 执行远程系统调用。 |

## 4. 遇到的主要困难 (Challenges)

1.  **环境限制**:
    - 目标设备没有 Python3，导致很多脚本无法直接运行。
    - **解决方案**: 交叉编译 C 程序 (`aarch64-linux-gnu-gcc`) 并推送到设备运行。

2. **Anti-Dump / 内存访问限制**:
    - 运行时对 `/proc/pid/mem` 的常规访问无效。
    - **解决方案**: 确认为权限检查机制。通过 `ptrace` 的调试状态提升了访问权限，成功在无需 Frida 的情况下完成了内存镜像的提取。

3.  **Go 混淆**:
    - 符号表损坏，无法直接通过 `nm` 或 Ghidra Script 恢复函数名。
    - **解决方案**: 基于字符串交叉引用 (String Xrefs) 定位关键逻辑。

## 5. 最终成果与方案 (Final Solution)

我们最终放弃了 Patch 二进制文件（因为运行时不可写不可读），转而采用了更优雅的 **Mock Daemon (伪装服务)** 方案。

- **原理**: Daemon 的通信协议是对称加密的，且密钥源自 App 签名（公开信息）。我们可以自己搭建一个“假服务端”。
- **实施**:
    1.  计算密钥: `MD5(AppSignature)`。
    2.  构造响应: `success@9999999999` (永不过期)。
    3.  加密: 使用 AES-256-ECB 加密响应。
    4.  部署: 使用 `nc -l -p 8765` 监听端口并返回该响应。


## 6. 文件清单与溯源 (File Inventory & Provenance)

以下是工作目录中生成/使用的关键文件及其来源：

### A. 核心产物 (Core Artifacts)
1. **[stage4_unpacked_ram.elf](file:///home/xiaotong/EzXHepler-template/stage4_unpacked_ram.elf)**
   - **类型**: ELF 64-bit LSB shared object (Go binary)
   - **用途**: 最终脱壳后的业务逻辑 Daemon，包含所有 API 处理流程。
   - **来源历史**: `scan_mem <pid> <start> <size> stage4_unpacked_ram.elf` (推荐方法) 或 `frida`。

2. **[payload.b64](file:///home/xiaotong/EzXHepler-template/payload.b64)**
   - **类型**: ASCII text, with no line terminators
   - **用途**: Base64 编码的加密响应，用于 nc 回复。
   - **来源命令**: `openssl enc -aes-256-ecb -K ... -in response.txt | base64 > payload.b64`
     *(注: `...` 代表省略的具体 Key/IV 参数，完整命令较长，详见 [gen_mock_response.py](file:///home/xiaotong/EzXHepler-template/gen_mock_response.py) 中的生成逻辑)*

3. **[encrypted.bin](file:///home/xiaotong/EzXHepler-template/encrypted.bin)**
   - **类型**: Data
   - **用途**: AES 加密后的响应二进制。
   - **来源命令**: `openssl enc -aes-256-ecb ... -out encrypted.bin`

### B. 辅助脚本 (Helper Scripts)
4. **[frida_manager.py](file:///home/xiaotong/EzXHepler-template/frida_manager.py) / [dump.js](file:///home/xiaotong/EzXHepler-template/dump.js)**
   - **类型**: Python script / ASCII text
   - **用途**: Frida 自动化脱壳工具。
   - **来源历史**: `python3 frida_manager.py`

5. **[gen_mock_response.py](file:///home/xiaotong/EzXHepler-template/gen_mock_response.py)**
   - **类型**: Python script
   - **用途**: 生成 Mock 响应的 Python 原型（后转为 Shell/OpenSSL 实现）。
   - **来源历史**: `python3 gen_mock_response.py`

6. **[scan_mem.c](file:///home/xiaotong/EzXHepler-template/scan_mem.c) / [scan_mem](file:///home/xiaotong/EzXHepler-template/scan_mem)**
   - **类型**: C source / ELF 64-bit LSB (Static)
   - **用途**: **核心脱离与转储工具**。支持内存搜索和基于 `ptrace` 的强制内存转储。
   - **来源历史**: 经过多次迭代，最终版本集成了转储逻辑，用于绕过 I/O 错误限制。

7. **[inject_mprotect.c](file:///home/xiaotong/EzXHepler-template/inject_mprotect.c) / [inject_mprotect](file:///home/xiaotong/EzXHepler-template/inject_mprotect)**
   - **类型**: C source / ELF 64-bit LSB executable
   - **用途**: `ptrace` 注入修改权限工具。**(失败尝试 / Failed Attempt)** - 即使修改权限为 rwx，读取依然全零，证实受到内核级 XOM 保护。
   - **来源命令**: `aarch64-linux-gnu-gcc inject_mprotect.c -o inject_mprotect`

### C. 中间文件 (Intermediate Files)
8. **[maps.txt](file:///home/xiaotong/EzXHepler-template/maps.txt) / [maps_30585.txt](file:///home/xiaotong/EzXHepler-template/maps_30585.txt)**
   - **类型**: ASCII text
   - **用途**: 进程内存映射快照。
   - **来源命令**: `adb shell cat /proc/$pid/maps > maps.txt`

9. **[st4_rodata.bin](file:///home/xiaotong/EzXHepler-template/st4_rodata.bin)**
   - **类型**: Data
   - **用途**: 从 `stage4` 中提取的只读数据段（包含字符串）。
   - **来源命令**: `dd if=stage4.bin ...` **(早期尝试 / Early Attempt)** - 虽获取了部分字符串，但已被完整的 Frida Dump ([stage4_unpacked_ram.elf](file:///home/xiaotong/EzXHepler-template/stage4_unpacked_ram.elf)) 取代。

---

## 7. 工具实现原理 (Tool Implementation Principles)

为了方便后续复现，本节详细说明各个核心工具的底层逻辑。

### 7.1 scan_mem.c (越权内存转储)
针对受限进程（无法直接读取 `/proc/pid/mem`）的通用转储逻辑。
1. **附着 (Attach)**: 调用 `ptrace(PTRACE_ATTACH, pid)`。此操作是必须的，因为它会将当前进程标记为调试器，从而在内核层面获得读取目标进程虚拟内存页面的合法权限。
2. **扫描 (Scanning)**:
   - 读取 `/proc/pid/maps` 获取所有内存段。
   - 打开 `/proc/pid/mem`。
   - 遍历每一段 `r--p` 或 `r-xp` 的内容。
   - 使用 `pread(fd, buffer, length, offset)` 在指定位置读取。
3. **识别 (Identification)**: 在读取的缓冲区头部匹配 `\x7fELF` (ELF Magic)。
4. **转储 (Dumping)**:
   - 一旦匹配到魔数且地址范围符合预期（如超过 1MB），将该段内容通过 `fwrite` 完整写入文件。
5. **脱离 (Detach)**: 调用 `ptrace(PTRACE_DETACH, pid)` 恢复进程逻辑。

### 7.2 dump.js (Frida 动态拦截)
利用动态 Hook 技术截获加壳程序的解压瞬间。
1. **Hook mprotect**: 拦截 [libc.so](file:///home/xiaotong/EzXHepler-template/libc.so) 中的 [mprotect](file:///home/xiaotong/EzXHepler-template/inject_mprotect) 函数。
2. **过滤行为**:
   - 观察参数 [prot](file:///home/xiaotong/EzXHepler-template/dump.js#19-54)（权限位）。如果出现 `prot=5` (R-X) 或 `prot=7` (RWX)，且 [size](file:///home/xiaotong/ghidra/bridge_mcp_ghidra.py#519-543) 较大（通常 > 1MB），则极有可能是壳程序正在将解压后的代码段设置为可执行。
3. **数据提取**: 
   - 在 [onLeave](file:///home/xiaotong/EzXHepler-template/dump.js#35-45)（函数返回）时，确认修改权限成功。
   - 调用 `Memory.readByteArray(addr, size)` 将解压后的 Payload 读入 JS 环境。
4. **回传 (Backchannel)**: 使用 `send(msg, data)` 将二进制流发送给 Host 端的 Python 脚本并发保存。

### 7.3 frida_manager.py (自动化注入)
协调 Frida 脚本与物理设备的生命周期。
1. **设备发现**: 使用 `frida.get_usb_device()` 定位 Android 设备。
2. **附加进程**:
   - 在循环中尝试 `device.attach("scene-daemon")`。
   - 这种“轮询附加”逻辑可以捕获那些频繁重启、崩溃或刚启动的加壳进程。
3. **加载脚本**: 将 [dump.js](file:///home/xiaotong/EzXHepler-template/dump.js) 编译并推送到目标进程。
4. **消息转发**: 定义 [on_message](file:///home/xiaotong/EzXHepler-template/frida_manager.py#5-10) 回调，捕获脚本发送的 `send()` 消息。如果消息包含文件内容，则自动创建本地文件并写入二进制流。

### 7.4 gen_mock_response.py (协议仿真)
复现 Daemon 激活通信的关键数学逻辑。
1. **密钥派生 (Key Derivation)**:
   - 读取 App 的签名证书（或硬编码的 Base64 签名）。
   - 计算该签名字符串的 MD5 哈希值。
   - 该 MD5 结果即为后续 AES 加密的 32 字节 Key（AES-256-ECB 模式）。
2. **明文构造**:
   - 构造字符串 `success@<timestamp>`，其中时间戳建议设为 `9999999999`。
3. **填充 (Padding)**: 
   - 使用 **PKCS7** 标准补齐至 16 字节的倍数。
4. **加密 (Encryption)**:
   - 使用 `AES.MODE_ECB` 模式（无 IV）。
5. **封装**: 将结果进行 Base64 编码，方便通过命令行工具（如 [nc](file:///home/xiaotong/ghidra/bridge_mcp_ghidra.py#1131-1149)）回显。

### 7.5 inject_mprotect.c (Syscall 命令注入)
一种无需劫持指令流即可执行任意系统调用的高级技巧。
1. **寄存器备份**: 使用 `PTRACE_GETREGS` 保存当前的 CPU 状态（PC, SP, X0-X7 等）。
2. **构造调用**:
   - 将 X8 寄存器设为系统调用号（如 `__NR_mprotect`）。
   - 将 X0-X2 设为参数（目标起始地址、长度、新权限）。
3. **触发执行**: 
   - 将当前指令指针 (PC) 指向内存中的 `SVC #0` 指令地址（通常在 `libc` 的系统调用包装函数中搜索该特征）。
   - 执行 `PTRACE_SINGLESTEP`。
4. **获取结果**: 读取 X0 寄存器获取返回值。
5. **恢复现场**: 将备份的寄存器值写回，进程无感继续运行。

